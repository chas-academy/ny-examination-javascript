name: "Grading Feedback"
description: "Generates feedback table based on config"
inputs:
  steps-context:
    description: "JSON string of the steps context"
    required: true
runs:
  using: "composite"
  steps:
    - name: Skapa/Uppdatera Feedback
      uses: actions/github-script@v7
      env:
        # Vi skickar in testresultaten sÃ¤kert via miljÃ¶variabler
        STEPS_CONTEXT: ${{ inputs.steps-context }}
        STUDENT_ID: ${{ env.STUDENT_ID }}
      with:
        script: |
          const fs = require('fs');
          // HÃ¤mta resultaten frÃ¥n input
          const steps = JSON.parse(process.env.STEPS_CONTEXT);
          const githubUser = context.actor;

          // 1. LÃ„S KONFIGURATION
          let tests = [];
          try {
            const configPath = '.github/classroom/grading-config.json';
            if (fs.existsSync(configPath)) {
              tests = JSON.parse(fs.readFileSync(configPath, 'utf8'));
            } else {
              console.log("::warning::Ingen grading-config.json hittades.");
            }
          } catch (e) { console.log("Config fel: " + e.message); }

          // 2. BERÃ„KNA POÃ„NG
          let totalScore = 0;
          let maxScore = 0;
          let rows = [];
          let requiredTestFailed = false;

          for (const test of tests) {
            const step = steps[test.id];
            let passed = false;
            if (step && step.outputs && step.outputs.result) {
              const raw = step.outputs.result;
              try {
                const json = JSON.parse(Buffer.from(raw, 'base64').toString('utf-8'));
                if (json.status === 'pass' || json.status === 'success') passed = true;
              } catch (e) {
                if (raw === 'success' || raw === 'pass') passed = true;
              }
            }
            if (test.required && !passed) requiredTestFailed = true;

            const icon = passed ? 'âœ…' : 'âŒ';
            const score = passed ? test.points : 0;
            totalScore += score;
            maxScore += test.points;
            rows.push(`| ${icon} | ${test.name} | ${score} / ${test.points} |`);
          }

          // 3. BYGG MEDDELANDE
          const studentId = process.env.STUDENT_ID || "Ej hittat";
          let commentBody = "";
          const botSignature = "";

          if (requiredTestFailed) {
            commentBody = `## âš ï¸ Obligatoriskt test misslyckades\n**Student:** @${githubUser}\n\nNÃ¥got grundlÃ¤ggande saknas (t.ex. ID eller kompilering).\nKontrollera loggarna.`;
          } else {
            commentBody = `## ðŸ¤– Automatisk RÃ¤ttning\n**Student:** @${githubUser}\n**Student ID:** ${studentId}\n**Totalt:** ${totalScore} / ${maxScore} poÃ¤ng\n\n| Status | Test | PoÃ¤ng |\n| :---: | :--- | :---: |\n${rows.join('\n')}`;
          }
          commentBody += `\n\n${botSignature}`;

          // 4. POSTA KOMMENTAR
          try {
            const prs = await github.rest.pulls.list({ owner: context.repo.owner, repo: context.repo.repo, state: 'open' });
            if (prs.data.length > 0) {
              const prNumber = prs.data[0].number;
              const comments = await github.rest.issues.listComments({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber });
              const botComment = comments.data.find(c => c.body.includes(botSignature));
              
              if (botComment) {
                await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: botComment.id, body: commentBody });
              } else {
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body: commentBody });
              }
            }
          } catch (e) { console.log("Kommentar fel: " + e.message); }
